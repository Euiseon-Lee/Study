class Solution {
    public int solution(int a, int b) {
        /*
         * [문제 설명]
         * 두 정수 a, b를 문자열처럼 앞뒤로 이어붙여 만든 두 수 "ab", "ba" 중 더 큰 값을 반환하는 문제.
         *
         * [접근 방식]
         * 문자열을 실제로 이어붙이는 대신, a와 b의 자릿수를 수학적으로 계산한 후,
         * 정수 덧셈과 곱셈만으로 "이어붙인 것과 같은 효과"를 만드는 방식이다.
         *
         * 예:
         *  a = 12, b = 34
         *  → "1234" 와 "3412" 중 더 큰 값 = 3412
         *
         * [핵심 처리]
         * - Math.log10(n): n이 몇 자리 숫자인지를 실수 형태로 구한다.
         *      예) log10(123) ≈ 2.09 → int로 내리면 2
         * - +1: 자릿수 완성 (log10 기반 계산은 항상 '자리 - 1'로 나오기 때문)
         * - Math.pow(10, 자리수): 실제로 자릿수를 확장하는 데 필요한 수
         *      예) 자리수 = 2 → 10^2 = 100
         *      → 곱하기 100을 하면 a는 그만큼 자릿수가 늘어나고 뒤에 b를 더해서 ab가 완성됨.
         *      → 즉, "a * 100 + b" 는 실제로 "ab"와 동일한 수학적 효과를 가짐
         *
         * [전체 로직]
         * 1. digitB = 10의 b의 자릿수 제곱
         * 2. digitA = 10의 a의 자릿수 제곱
         * 3. ab = a * digitB + b
         * 4. ba = b * digitA + a
         * 5. 둘 중 큰 값 반환
         *
         * [예외 처리]
         * - 문제에서 1 ≤ a, b < 10,000 이 보장되므로 log10(0) 예외는 발생하지 않음
         *
         * [비교: 문자열 방식]
         * - 대안으로 Integer.parseInt("" + a + b) 방식도 있으나 다음과 같은 단점이 있음
         * - 문자열 "" + a → 임시 문자열 생성 ("12")
         * - 문자열 + b → 또 다른 문자열 생성 ("1234")
         * - 이 모든 문자열은 힙 메모리에 올라가며, 이후 GC 대상이 됨
         * - 즉, 짧은 코드지만 실제로는 불필요한 객체가 최소 2개 이상 만들어짐
         *
         * 반면 수학적으로 처리하는 방식은:
         * - 모든 연산이 int, double 등 기본형만 사용됨
         * - 문자열 객체 생성이 전혀 없으므로 메모리 효율과 GC 부담 측면에서 유리함
         *
         * [접근 수준 평가]
         * - 문자열을 직접 붙이지 않고 자릿수 계산으로 해결하는 방식은
         *   구현력을 넘어서 '자료 구조 없이 수치 기반 최적화'를 감각적으로 해낸 상급 풀이.
         * - 수학/시뮬레이션 문제에서 문자열 대신 숫자만으로 계산하는 센스를 보여주는 코드로,
         *   코딩 테스트 상위권이나 알고리즘 경시 문제에서 흔히 요구되는 수준.
         */
        int digitA = (int) Math.pow(10, (int) Math.log10(Math.abs(a)) + 1);
        int digitB = (int) Math.pow(10, (int) Math.log10(Math.abs(b)) + 1);
        return Math.max((a * digitB) + b, (b * digitA) + a);
    }
}
