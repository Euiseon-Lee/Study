class Solution {
    public int[] solution(int n, int k) {
        /**
         * 🚀 n 이하의 k의 배수를 효율적으로 구하는 반복 최적화 전략
         *
         * ✅ 핵심 개선 포인트
         * - 원래는 1부터 n까지 모든 수를 순회하며 조건문 (i % k == 0)으로 필터링했지만,
         *   사실상 k의 배수만 관심 대상이므로, 처음부터 i = k, step = k로 반복 구조를 바꾸는 것이 더 효율적임
         * - 조건문을 완전히 제거하고, 필요한 값만 정확히 순회하므로 무효 루프 없이 결과를 수집할 수 있음
         *
         * ✅ 루프 구조와 성능
         * - 반복은 i = k부터 n까지 k 간격으로만 순회 → 조건 없이 루프 자체가 정답
         * - 배열 크기 또한 n / k로 정확히 계산되므로 List 없이 배열 직접 할당 가능
         * - 조건 비교 제거 + 불필요한 객체 생성을 피함으로써 GC 부담도 줄이고 실행 속도 향상
         *
         * ✅ 예시
         * - n = 10, k = 3일 때 → 루프는 i = 3, 6, 9 순회 (i % k == 0 체크 없이 정확히 반복)
         *
         * ✅ 실무 적용 팁
         * - 결과 개수가 명확히 예측되면 List 대신 배열을 고려 (GC, 메모리 효율 ↑)
         * - 특정 패턴 값이 반복된다면, 조건 필터링보다 스텝 기반 루프(for (i += k))가 효율적
         * - 특히 대량 데이터나 실시간 계산 상황에서는 조건 제거 최적화가 유효함
         *
         * ✅ 정리
         * - 조건 기반 루프에서 → 조건 자체를 제거한 반복 구조로 전환한 점이 탁월함
         * - 코드 성능만이 아니라, 반복 구조 자체를 재설계하는 사고력이 돋보이는 예시
         * - "내 코드가 구조적으로 불필요한 낭비를 하고 있지는 않은가?"라는 질문을
         *   지속적으로 던지는 습관이 잘 드러났고, 이는 실무에서도 큰 경쟁력이 될 수 있어!
         */
        int[] answer = new int[n / k];
        /* 기존 코드 - n + 1까지 하나씩 증가, 속도가 느림
        for (int i = 1, idx = 0; i < n + 1; i++) {
            if (i % k == 0) {
                answer[idx++] = i;
            }
        }
        */
        for (int i = k, idx = 0; i <= n; i += k) {
            answer[idx++] = i;
        }
        return answer;
    }
}
